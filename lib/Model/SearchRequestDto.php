<?php
/**
 * SearchRequestDto
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Groupby\RetailApiClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * GroupBy Retail
 *
 * GroupBy Retail API
 *
 * The version of the OpenAPI document: 0.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Groupby\RetailApiClient\Model;

use \ArrayAccess;
use \Groupby\RetailApiClient\ObjectSerializer;

/**
 * SearchRequestDto Class Doc Comment
 *
 * @category Class
 * @description Request that should be populated to configure a search API call, made by the client on behalf of a shopper.
 * @package  Groupby\RetailApiClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class SearchRequestDto implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'SearchRequestDto';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'query' => 'string',
        'area' => 'string',
        'collection' => 'string',
        'visitor_id' => 'string',
        'refinements' => '\Groupby\RetailApiClient\Model\SelectedRefinementDto[]',
        'page_size' => 'int',
        'skip' => 'int',
        'biasing_profile' => 'string',
        'biasing' => '\Groupby\RetailApiClient\Model\BiasingProfileDto',
        'custom_url_params' => '\Groupby\RetailApiClient\Model\CustomParameterDto[]',
        'sorts' => '\Groupby\RetailApiClient\Model\SortDto[]',
        'included_navigations' => 'string[]',
        'excluded_navigations' => 'string[]',
        'dynamic_facet' => 'bool',
        'variant_rollup_keys' => 'string[]',
        'pre_filter' => 'string',
        'site' => 'string',
        'response_mask' => 'string[]',
        'page_categories' => 'string[]',
        'spell_correction_mode' => 'SpellCorrectionMode',
        'include_expanded_results' => 'bool',
        'pin_unexpanded_results' => 'bool',
        'debug' => 'bool',
        'facet_limit' => 'int',
        'login_id' => 'string',
        'overwrites' => '\Groupby\RetailApiClient\Model\SearchRequestDtoOverwrites'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'query' => null,
        'area' => null,
        'collection' => null,
        'visitor_id' => null,
        'refinements' => null,
        'page_size' => 'int32',
        'skip' => 'int64',
        'biasing_profile' => null,
        'biasing' => null,
        'custom_url_params' => null,
        'sorts' => null,
        'included_navigations' => null,
        'excluded_navigations' => null,
        'dynamic_facet' => null,
        'variant_rollup_keys' => null,
        'pre_filter' => null,
        'site' => null,
        'response_mask' => null,
        'page_categories' => null,
        'spell_correction_mode' => null,
        'include_expanded_results' => null,
        'pin_unexpanded_results' => null,
        'debug' => null,
        'facet_limit' => 'int32',
        'login_id' => null,
        'overwrites' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'query' => true,
		'area' => true,
		'collection' => true,
		'visitor_id' => true,
		'refinements' => false,
		'page_size' => true,
		'skip' => true,
		'biasing_profile' => true,
		'biasing' => true,
		'custom_url_params' => false,
		'sorts' => false,
		'included_navigations' => true,
		'excluded_navigations' => true,
		'dynamic_facet' => true,
		'variant_rollup_keys' => true,
		'pre_filter' => true,
		'site' => true,
		'response_mask' => true,
		'page_categories' => true,
		'spell_correction_mode' => true,
		'include_expanded_results' => true,
		'pin_unexpanded_results' => true,
		'debug' => true,
		'facet_limit' => true,
		'login_id' => true,
		'overwrites' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'query' => 'query',
        'area' => 'area',
        'collection' => 'collection',
        'visitor_id' => 'visitorId',
        'refinements' => 'refinements',
        'page_size' => 'pageSize',
        'skip' => 'skip',
        'biasing_profile' => 'biasingProfile',
        'biasing' => 'biasing',
        'custom_url_params' => 'customUrlParams',
        'sorts' => 'sorts',
        'included_navigations' => 'includedNavigations',
        'excluded_navigations' => 'excludedNavigations',
        'dynamic_facet' => 'dynamicFacet',
        'variant_rollup_keys' => 'variantRollupKeys',
        'pre_filter' => 'preFilter',
        'site' => 'site',
        'response_mask' => 'responseMask',
        'page_categories' => 'pageCategories',
        'spell_correction_mode' => 'spellCorrectionMode',
        'include_expanded_results' => 'includeExpandedResults',
        'pin_unexpanded_results' => 'pinUnexpandedResults',
        'debug' => 'debug',
        'facet_limit' => 'facetLimit',
        'login_id' => 'loginId',
        'overwrites' => 'overwrites'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'query' => 'setQuery',
        'area' => 'setArea',
        'collection' => 'setCollection',
        'visitor_id' => 'setVisitorId',
        'refinements' => 'setRefinements',
        'page_size' => 'setPageSize',
        'skip' => 'setSkip',
        'biasing_profile' => 'setBiasingProfile',
        'biasing' => 'setBiasing',
        'custom_url_params' => 'setCustomUrlParams',
        'sorts' => 'setSorts',
        'included_navigations' => 'setIncludedNavigations',
        'excluded_navigations' => 'setExcludedNavigations',
        'dynamic_facet' => 'setDynamicFacet',
        'variant_rollup_keys' => 'setVariantRollupKeys',
        'pre_filter' => 'setPreFilter',
        'site' => 'setSite',
        'response_mask' => 'setResponseMask',
        'page_categories' => 'setPageCategories',
        'spell_correction_mode' => 'setSpellCorrectionMode',
        'include_expanded_results' => 'setIncludeExpandedResults',
        'pin_unexpanded_results' => 'setPinUnexpandedResults',
        'debug' => 'setDebug',
        'facet_limit' => 'setFacetLimit',
        'login_id' => 'setLoginId',
        'overwrites' => 'setOverwrites'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'query' => 'getQuery',
        'area' => 'getArea',
        'collection' => 'getCollection',
        'visitor_id' => 'getVisitorId',
        'refinements' => 'getRefinements',
        'page_size' => 'getPageSize',
        'skip' => 'getSkip',
        'biasing_profile' => 'getBiasingProfile',
        'biasing' => 'getBiasing',
        'custom_url_params' => 'getCustomUrlParams',
        'sorts' => 'getSorts',
        'included_navigations' => 'getIncludedNavigations',
        'excluded_navigations' => 'getExcludedNavigations',
        'dynamic_facet' => 'getDynamicFacet',
        'variant_rollup_keys' => 'getVariantRollupKeys',
        'pre_filter' => 'getPreFilter',
        'site' => 'getSite',
        'response_mask' => 'getResponseMask',
        'page_categories' => 'getPageCategories',
        'spell_correction_mode' => 'getSpellCorrectionMode',
        'include_expanded_results' => 'getIncludeExpandedResults',
        'pin_unexpanded_results' => 'getPinUnexpandedResults',
        'debug' => 'getDebug',
        'facet_limit' => 'getFacetLimit',
        'login_id' => 'getLoginId',
        'overwrites' => 'getOverwrites'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('query', $data ?? [], null);
        $this->setIfExists('area', $data ?? [], 'Production');
        $this->setIfExists('collection', $data ?? [], 'default');
        $this->setIfExists('visitor_id', $data ?? [], null);
        $this->setIfExists('refinements', $data ?? [], null);
        $this->setIfExists('page_size', $data ?? [], 10);
        $this->setIfExists('skip', $data ?? [], 0);
        $this->setIfExists('biasing_profile', $data ?? [], null);
        $this->setIfExists('biasing', $data ?? [], null);
        $this->setIfExists('custom_url_params', $data ?? [], null);
        $this->setIfExists('sorts', $data ?? [], null);
        $this->setIfExists('included_navigations', $data ?? [], null);
        $this->setIfExists('excluded_navigations', $data ?? [], null);
        $this->setIfExists('dynamic_facet', $data ?? [], null);
        $this->setIfExists('variant_rollup_keys', $data ?? [], null);
        $this->setIfExists('pre_filter', $data ?? [], null);
        $this->setIfExists('site', $data ?? [], null);
        $this->setIfExists('response_mask', $data ?? [], null);
        $this->setIfExists('page_categories', $data ?? [], null);
        $this->setIfExists('spell_correction_mode', $data ?? [], null);
        $this->setIfExists('include_expanded_results', $data ?? [], null);
        $this->setIfExists('pin_unexpanded_results', $data ?? [], null);
        $this->setIfExists('debug', $data ?? [], null);
        $this->setIfExists('facet_limit', $data ?? [], null);
        $this->setIfExists('login_id', $data ?? [], null);
        $this->setIfExists('overwrites', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['refinements'] === null) {
            $invalidProperties[] = "'refinements' can't be null";
        }
        if (!is_null($this->container['page_size']) && ($this->container['page_size'] < 0)) {
            $invalidProperties[] = "invalid value for 'page_size', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['skip']) && ($this->container['skip'] < 0)) {
            $invalidProperties[] = "invalid value for 'skip', must be bigger than or equal to 0.";
        }

        if ($this->container['biasing'] === null) {
            $invalidProperties[] = "'biasing' can't be null";
        }
        if ($this->container['custom_url_params'] === null) {
            $invalidProperties[] = "'custom_url_params' can't be null";
        }
        if ($this->container['sorts'] === null) {
            $invalidProperties[] = "'sorts' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets query
     *
     * @return string|null
     */
    public function getQuery()
    {
        return $this->container['query'];
    }

    /**
     * Sets query
     *
     * @param string|null $query Base textual search query.
     *
     * @return self
     */
    public function setQuery($query)
    {
        if (is_null($query)) {
            array_push($this->openAPINullablesSetToNull, 'query');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('query', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['query'] = $query;

        return $this;
    }

    /**
     * Gets area
     *
     * @return string|null
     */
    public function getArea()
    {
        return $this->container['area'];
    }

    /**
     * Sets area
     *
     * @param string|null $area Area name the search is being performed in.
     *
     * @return self
     */
    public function setArea($area)
    {
        if (is_null($area)) {
            array_push($this->openAPINullablesSetToNull, 'area');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('area', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['area'] = $area;

        return $this;
    }

    /**
     * Gets collection
     *
     * @return string|null
     */
    public function getCollection()
    {
        return $this->container['collection'];
    }

    /**
     * Sets collection
     *
     * @param string|null $collection Name of collection in project configuration setting which is mapped to the google retail backend.
     *
     * @return self
     */
    public function setCollection($collection)
    {
        if (is_null($collection)) {
            array_push($this->openAPINullablesSetToNull, 'collection');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('collection', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['collection'] = $collection;

        return $this;
    }

    /**
     * Gets visitor_id
     *
     * @return string|null
     */
    public function getVisitorId()
    {
        return $this->container['visitor_id'];
    }

    /**
     * Sets visitor_id
     *
     * @param string|null $visitor_id Unique identifier identifying the shopper. Will be autogenerated if not provided.
     *
     * @return self
     */
    public function setVisitorId($visitor_id)
    {
        if (is_null($visitor_id)) {
            array_push($this->openAPINullablesSetToNull, 'visitor_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('visitor_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['visitor_id'] = $visitor_id;

        return $this;
    }

    /**
     * Gets refinements
     *
     * @return \Groupby\RetailApiClient\Model\SelectedRefinementDto[]
     */
    public function getRefinements()
    {
        return $this->container['refinements'];
    }

    /**
     * Sets refinements
     *
     * @param \Groupby\RetailApiClient\Model\SelectedRefinementDto[] $refinements refinements
     *
     * @return self
     */
    public function setRefinements($refinements)
    {
        if (is_null($refinements)) {
            throw new \InvalidArgumentException('non-nullable refinements cannot be null');
        }
        $this->container['refinements'] = $refinements;

        return $this;
    }

    /**
     * Gets page_size
     *
     * @return int|null
     */
    public function getPageSize()
    {
        return $this->container['page_size'];
    }

    /**
     * Sets page_size
     *
     * @param int|null $page_size The number of products to be returned on each page.
     *
     * @return self
     */
    public function setPageSize($page_size)
    {
        if (is_null($page_size)) {
            array_push($this->openAPINullablesSetToNull, 'page_size');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('page_size', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        if (!is_null($page_size) && ($page_size < 0)) {
            throw new \InvalidArgumentException('invalid value for $page_size when calling SearchRequestDto., must be bigger than or equal to 0.');
        }

        $this->container['page_size'] = $page_size;

        return $this;
    }

    /**
     * Gets skip
     *
     * @return int|null
     */
    public function getSkip()
    {
        return $this->container['skip'];
    }

    /**
     * Sets skip
     *
     * @param int|null $skip Where in the list of products to begin the page.
     *
     * @return self
     */
    public function setSkip($skip)
    {
        if (is_null($skip)) {
            array_push($this->openAPINullablesSetToNull, 'skip');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('skip', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        if (!is_null($skip) && ($skip < 0)) {
            throw new \InvalidArgumentException('invalid value for $skip when calling SearchRequestDto., must be bigger than or equal to 0.');
        }

        $this->container['skip'] = $skip;

        return $this;
    }

    /**
     * Gets biasing_profile
     *
     * @return string|null
     */
    public function getBiasingProfile()
    {
        return $this->container['biasing_profile'];
    }

    /**
     * Sets biasing_profile
     *
     * @param string|null $biasing_profile Name of a biasing profile which should be applied to the search. Takes priority over area default.
     *
     * @return self
     */
    public function setBiasingProfile($biasing_profile)
    {
        if (is_null($biasing_profile)) {
            array_push($this->openAPINullablesSetToNull, 'biasing_profile');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('biasing_profile', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['biasing_profile'] = $biasing_profile;

        return $this;
    }

    /**
     * Gets biasing
     *
     * @return \Groupby\RetailApiClient\Model\BiasingProfileDto
     */
    public function getBiasing()
    {
        return $this->container['biasing'];
    }

    /**
     * Sets biasing
     *
     * @param \Groupby\RetailApiClient\Model\BiasingProfileDto $biasing biasing
     *
     * @return self
     */
    public function setBiasing($biasing)
    {
        if (is_null($biasing)) {
            array_push($this->openAPINullablesSetToNull, 'biasing');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('biasing', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['biasing'] = $biasing;

        return $this;
    }

    /**
     * Gets custom_url_params
     *
     * @return \Groupby\RetailApiClient\Model\CustomParameterDto[]
     */
    public function getCustomUrlParams()
    {
        return $this->container['custom_url_params'];
    }

    /**
     * Sets custom_url_params
     *
     * @param \Groupby\RetailApiClient\Model\CustomParameterDto[] $custom_url_params custom_url_params
     *
     * @return self
     */
    public function setCustomUrlParams($custom_url_params)
    {
        if (is_null($custom_url_params)) {
            throw new \InvalidArgumentException('non-nullable custom_url_params cannot be null');
        }
        $this->container['custom_url_params'] = $custom_url_params;

        return $this;
    }

    /**
     * Gets sorts
     *
     * @return \Groupby\RetailApiClient\Model\SortDto[]
     */
    public function getSorts()
    {
        return $this->container['sorts'];
    }

    /**
     * Sets sorts
     *
     * @param \Groupby\RetailApiClient\Model\SortDto[] $sorts sorts
     *
     * @return self
     */
    public function setSorts($sorts)
    {
        if (is_null($sorts)) {
            throw new \InvalidArgumentException('non-nullable sorts cannot be null');
        }
        $this->container['sorts'] = $sorts;

        return $this;
    }

    /**
     * Gets included_navigations
     *
     * @return string[]|null
     */
    public function getIncludedNavigations()
    {
        return $this->container['included_navigations'];
    }

    /**
     * Sets included_navigations
     *
     * @param string[]|null $included_navigations Set of navigation fields to include in the search result. Cannot be set if 'excludedNavigations' is set.
     *
     * @return self
     */
    public function setIncludedNavigations($included_navigations)
    {
        if (is_null($included_navigations)) {
            array_push($this->openAPINullablesSetToNull, 'included_navigations');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('included_navigations', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['included_navigations'] = $included_navigations;

        return $this;
    }

    /**
     * Gets excluded_navigations
     *
     * @return string[]|null
     */
    public function getExcludedNavigations()
    {
        return $this->container['excluded_navigations'];
    }

    /**
     * Sets excluded_navigations
     *
     * @param string[]|null $excluded_navigations Set of navigation fields to exclude in the search result. Cannot be set if 'includedNavigations' is set.
     *
     * @return self
     */
    public function setExcludedNavigations($excluded_navigations)
    {
        if (is_null($excluded_navigations)) {
            array_push($this->openAPINullablesSetToNull, 'excluded_navigations');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('excluded_navigations', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['excluded_navigations'] = $excluded_navigations;

        return $this;
    }

    /**
     * Gets dynamic_facet
     *
     * @return bool|null
     */
    public function getDynamicFacet()
    {
        return $this->container['dynamic_facet'];
    }

    /**
     * Sets dynamic_facet
     *
     * @param bool|null $dynamic_facet Set the specifications of dynamically generated facets.
     *
     * @return self
     */
    public function setDynamicFacet($dynamic_facet)
    {
        if (is_null($dynamic_facet)) {
            array_push($this->openAPINullablesSetToNull, 'dynamic_facet');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('dynamic_facet', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['dynamic_facet'] = $dynamic_facet;

        return $this;
    }

    /**
     * Gets variant_rollup_keys
     *
     * @return string[]|null
     */
    public function getVariantRollupKeys()
    {
        return $this->container['variant_rollup_keys'];
    }

    /**
     * Sets variant_rollup_keys
     *
     * @param string[]|null $variant_rollup_keys Set the variant rollup keys.
     *
     * @return self
     */
    public function setVariantRollupKeys($variant_rollup_keys)
    {
        if (is_null($variant_rollup_keys)) {
            array_push($this->openAPINullablesSetToNull, 'variant_rollup_keys');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('variant_rollup_keys', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['variant_rollup_keys'] = $variant_rollup_keys;

        return $this;
    }

    /**
     * Gets pre_filter
     *
     * @return string|null
     */
    public function getPreFilter()
    {
        return $this->container['pre_filter'];
    }

    /**
     * Sets pre_filter
     *
     * @param string|null $pre_filter Set of the prefilter specifications value.
     *
     * @return self
     */
    public function setPreFilter($pre_filter)
    {
        if (is_null($pre_filter)) {
            array_push($this->openAPINullablesSetToNull, 'pre_filter');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('pre_filter', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['pre_filter'] = $pre_filter;

        return $this;
    }

    /**
     * Gets site
     *
     * @return string|null
     */
    public function getSite()
    {
        return $this->container['site'];
    }

    /**
     * Sets site
     *
     * @param string|null $site Name of site filter. If not specified, the specified area's default site will be applied if configured in Command Center. To not use default specify empty value i.e.\"\".  If the site doesn't exist then the search will execute without the site filter and a warning will be provided.
     *
     * @return self
     */
    public function setSite($site)
    {
        if (is_null($site)) {
            array_push($this->openAPINullablesSetToNull, 'site');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('site', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['site'] = $site;

        return $this;
    }

    /**
     * Gets response_mask
     *
     * @return string[]|null
     */
    public function getResponseMask()
    {
        return $this->container['response_mask'];
    }

    /**
     * Sets response_mask
     *
     * @param string[]|null $response_mask List with fields which should be included in metadata object associated with each record in response.
     *
     * @return self
     */
    public function setResponseMask($response_mask)
    {
        if (is_null($response_mask)) {
            array_push($this->openAPINullablesSetToNull, 'response_mask');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('response_mask', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['response_mask'] = $response_mask;

        return $this;
    }

    /**
     * Gets page_categories
     *
     * @return string[]|null
     */
    public function getPageCategories()
    {
        return $this->container['page_categories'];
    }

    /**
     * Sets page_categories
     *
     * @param string[]|null $page_categories The categories associated with a category page. Required for category navigation queries to achieve good search quality. To represent full path of category, use '>' sign to separate different hierarchies. If '>' is part of the category name, please replace it with other character(s).Max item length = 1.
     *
     * @return self
     */
    public function setPageCategories($page_categories)
    {
        if (is_null($page_categories)) {
            array_push($this->openAPINullablesSetToNull, 'page_categories');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('page_categories', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['page_categories'] = $page_categories;

        return $this;
    }

    /**
     * Gets spell_correction_mode
     *
     * @return SpellCorrectionMode|null
     */
    public function getSpellCorrectionMode()
    {
        return $this->container['spell_correction_mode'];
    }

    /**
     * Sets spell_correction_mode
     *
     * @param SpellCorrectionMode|null $spell_correction_mode spell_correction_mode
     *
     * @return self
     */
    public function setSpellCorrectionMode($spell_correction_mode)
    {
        if (is_null($spell_correction_mode)) {
            array_push($this->openAPINullablesSetToNull, 'spell_correction_mode');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('spell_correction_mode', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['spell_correction_mode'] = $spell_correction_mode;

        return $this;
    }

    /**
     * Gets include_expanded_results
     *
     * @return bool|null
     */
    public function getIncludeExpandedResults()
    {
        return $this->container['include_expanded_results'];
    }

    /**
     * Sets include_expanded_results
     *
     * @param bool|null $include_expanded_results When a shopper uses an ambiguous or a multi-word search phrase, they can get an empty response. After turning on include expanded results, Retail Search analyzes the request and returns the expanded list of products based on the parsed search query. For example, if you search \"Google Pixel 5\" without query expansion, you might only get \"google_pixel_5\" in the result. With query expansion, you might get \"google_pixel_4a_with_5g\", \"google_pixel_4a\" and \"google_pixel_5_case\" as well.The default value is configured in the tenant settings or true if there is no such setting
     *
     * @return self
     */
    public function setIncludeExpandedResults($include_expanded_results)
    {
        if (is_null($include_expanded_results)) {
            array_push($this->openAPINullablesSetToNull, 'include_expanded_results');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('include_expanded_results', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['include_expanded_results'] = $include_expanded_results;

        return $this;
    }

    /**
     * Gets pin_unexpanded_results
     *
     * @return bool|null
     */
    public function getPinUnexpandedResults()
    {
        return $this->container['pin_unexpanded_results'];
    }

    /**
     * Sets pin_unexpanded_results
     *
     * @param bool|null $pin_unexpanded_results This configuration depends on include expanded results settings. If this field is set to true,unexpanded products are always at the top of the search results, followed  by the expanded results. Default value: true
     *
     * @return self
     */
    public function setPinUnexpandedResults($pin_unexpanded_results)
    {
        if (is_null($pin_unexpanded_results)) {
            array_push($this->openAPINullablesSetToNull, 'pin_unexpanded_results');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('pin_unexpanded_results', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['pin_unexpanded_results'] = $pin_unexpanded_results;

        return $this;
    }

    /**
     * Gets debug
     *
     * @return bool|null
     */
    public function getDebug()
    {
        return $this->container['debug'];
    }

    /**
     * Sets debug
     *
     * @param bool|null $debug Enable additional debug info in response.  Note: attaching debug info significantly affects performance. Is not supposed to be used for large requests.
     *
     * @return self
     */
    public function setDebug($debug)
    {
        if (is_null($debug)) {
            array_push($this->openAPINullablesSetToNull, 'debug');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('debug', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['debug'] = $debug;

        return $this;
    }

    /**
     * Gets facet_limit
     *
     * @return int|null
     */
    public function getFacetLimit()
    {
        return $this->container['facet_limit'];
    }

    /**
     * Sets facet_limit
     *
     * @param int|null $facet_limit Maximum of facet values that should be returned for this facet. If not specified, defaults to 20. The maximum allowed value is 300. Values above 300 will be coerced to 300.  If this field is negative, an INVALID_ARGUMENT is returned.  This limit (300) is configured on Google side, but Google have an ability to change it for specific project.
     *
     * @return self
     */
    public function setFacetLimit($facet_limit)
    {
        if (is_null($facet_limit)) {
            array_push($this->openAPINullablesSetToNull, 'facet_limit');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('facet_limit', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['facet_limit'] = $facet_limit;

        return $this;
    }

    /**
     * Gets login_id
     *
     * @return string|null
     */
    public function getLoginId()
    {
        return $this->container['login_id'];
    }

    /**
     * Sets login_id
     *
     * @param string|null $login_id Highly recommended for logged-in users. Unique identifier for logged-in user, such as a user name. Don't set for anonymous users.  Don't set the field to the same fixed ID for different users. This mixes the event history of those users together, which results in degraded model quality.  The field must be a UTF-8 encoded string with a length limit of 128 characters.
     *
     * @return self
     */
    public function setLoginId($login_id)
    {
        if (is_null($login_id)) {
            array_push($this->openAPINullablesSetToNull, 'login_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('login_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['login_id'] = $login_id;

        return $this;
    }

    /**
     * Gets overwrites
     *
     * @return \Groupby\RetailApiClient\Model\SearchRequestDtoOverwrites|null
     */
    public function getOverwrites()
    {
        return $this->container['overwrites'];
    }

    /**
     * Sets overwrites
     *
     * @param \Groupby\RetailApiClient\Model\SearchRequestDtoOverwrites|null $overwrites overwrites
     *
     * @return self
     */
    public function setOverwrites($overwrites)
    {
        if (is_null($overwrites)) {
            array_push($this->openAPINullablesSetToNull, 'overwrites');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('overwrites', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['overwrites'] = $overwrites;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


